/**
 * This is an autogenerated netlist code from CircuitVerse. Verilog Code can be
 * tested on https://www.edaplayground.com/ using Icarus Verilog 0.9.7. This is an
 * experimental module and some manual changes make need to be done in order for
 * this to work.
 *
 * If you have any ideas/suggestions or bug fixes, raise an issue
 * on https://github.com/CircuitVerse/CircuitVerse/issues/new/choose
 */

/*
  Element Usage Report
    Input - 12 times
    AndGate - 2 times
    OrGate - 1 times
    Output - 7 times
    XorGate - 2 times
    SubCircuit - 4 times
*/

/*
  Usage Instructions and Tips
    Labels - Ensure unique label names and avoid using verilog keywords
    Warnings - Connect all optional inputs to remove warnings
*/

// Sample Testbench Code - Uncomment to use

/*
module TestBench();

  reg A0, B0, C1, A1, B1, A2, B2, A3, B3;

  wire C4, S0, S1, S2, S3;

  RCA DUT0(C4, S0, S1, S2, S3, A0, B0, C1, A1, B1, A2, B2, A3, B3);

  initial begin
    A0 = 0;
    B0 = 0;
    C1 = 0;
    A1 = 0;
    B1 = 0;
    A2 = 0;
    B2 = 0;
    A3 = 0;
    B3 = 0;

    #15
    $display("C4 = %b", C4);
    $display("S0 = %b", S0);
    $display("S1 = %b", S1);
    $display("S2 = %b", S2);
    $display("S3 = %b", S3);

    #10
    $display("C4 = %b", C4);
    $display("S0 = %b", S0);
    $display("S1 = %b", S1);
    $display("S2 = %b", S2);
    $display("S3 = %b", S3);

    $finish;

  end
endmodule

*/

module \1_bit_adder (S, Cout, A, B, Cin);
  output S,  Cout;
  input A, B, Cin;
  wire and_1_out, or_0_out, xor_1_out, and_0_out, xor_0_out;
  assign and_1_out = xor_0_out & Cin;
  assign or_0_out = and_0_out | and_1_out;
  assign Cout = or_0_out;
  assign xor_1_out = xor_0_out ^ Cin;
  assign S = xor_1_out;
  assign and_0_out = A & B;
  assign xor_0_out = A ^ B;
endmodule


module RCA(C4, S0, S1, S2, S3, A0, B0, C1, A1, B1, A2, B2, A3, B3);
  output C4,  S0,  S1,  S2,  S3;
  input A0, B0, C1, A1, B1, A2, B2, A3, B3;
  wire \1_bit_adder_3_out_0 , \1_bit_adder_3_out_1 , \1_bit_adder_2_out_0 , \1_bit_adder_2_out_1 , \1_bit_adder_1_out_0 , \1_bit_adder_1_out_1 , \1_bit_adder_0_out_0 , \1_bit_adder_0_out_1 ;
  \1_bit_adder  \1_bit_adder_3 (\1_bit_adder_3_out_0 , \1_bit_adder_3_out_1 , A3, B3, \1_bit_adder_2_out_1 );
  assign C4 = \1_bit_adder_3_out_1 ;
  assign S3 = \1_bit_adder_3_out_0 ;
  \1_bit_adder  \1_bit_adder_2 (\1_bit_adder_2_out_0 , \1_bit_adder_2_out_1 , A2, B2, \1_bit_adder_1_out_1 );
  assign S2 = \1_bit_adder_2_out_0 ;
  \1_bit_adder  \1_bit_adder_1 (\1_bit_adder_1_out_0 , \1_bit_adder_1_out_1 , A1, B1, \1_bit_adder_0_out_1 );
  assign S1 = \1_bit_adder_1_out_0 ;
  \1_bit_adder  \1_bit_adder_0 (\1_bit_adder_0_out_0 , \1_bit_adder_0_out_1 , A0, B0, C1);
  assign S0 = \1_bit_adder_0_out_0 ;
endmodule
